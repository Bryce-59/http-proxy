#!/usr/bin/env python3
import json
import os
import sys
import threading
from threading import Thread
import socket
from socket import *
import uuid

# what is left:
# TODO: check CONNECT
# TODO: fix up editHeader()
# TODO: implement correct ways to close client
# TODO: send() or sendall()
# TODO: handle HTTPS://
# TODO: design doc

# TCP Proxy Structure:
# _________________________________________________________
# main () ... opens proxy socket and starts the proxyThread
# | - > findClients () ... waits for clients to connect and starts clientThread
#       | - >   handleRequests () ... sends messages from client -> proxy -> server
#               | - - - > fetchHost() ... parse client's message for address and port (helper method)
#               | - - -> editHeader() ... edit client's message before sending it to server (helper method)
#               | - > startResponse() ... sends messages from server -> proxy -> client
#               | - >  startConnect()  ... sends messages from client -> proxy -> server (CONNECT)

# messages from client -> proxy -> server (browser)
def startConnect(serverSocket, clientSocket):
    while True:
        #rcv a message TODO: sendall?
        packet = clientSocket.recv(2048)
        serverSocket.send(packet)

# messages from server -> proxy -> client (browser)
def startResponse(serverSocket, clientSocket, file_name=None):
    while True:
        #rcv a message
        packet = serverSocket.recv(2048)
        
        if logging and file_name is not None:
            logMessage("Server response received",packet.decode("utf-8","backslashreplace"),file_name)
        
        #pass to real client
        clientSocket.send(packet)

def logMessage(title, message, file_name):
    data = json.load(open(file_name, 'r'))
    data[title] = message
    json.dump(data, open(file_name, "w"), indent = 3)    

def editHeader(clientRequest, file_name=None):
    header = clientRequest.decode("utf-8","backslashreplace")   
    # line_set = data.splitlines()
    # if line_set[0].find('HTTP/1.1') != -1:
    #     line_set[0].replace('HTTP/1.1', 'HTTP/1.0')

    # for line in line_set:
    #     if line.lower().find('connection:') != -1:
    #         line.replace('keep-alive','close')
    #         return 
    header = header.replace("HTTP/1.1", "HTTP/1.0") #TODO: elaborate on this
    header = header.replace("keep-alive", "close")
    
    if logging and file_name is not None:
        logMessage("Modified header",header,file_name)

    return header

def fetchHost(line_set):
    # HOST: <address>:<port>
    # HOST: <address>
    hostAddress = None
    for line in line_set:
        temp = line.lstrip()
        if temp[:4].lower() == 'host':
            hostAddress = line[line.find(':') + 1:].lstrip().rstrip() #HOST:[<address>:<port>] || HOST:[<address>]

            indexOne = hostAddress.find(':')
            if indexOne != -1:
                return hostAddress[:indexOne], int(hostAddress[indexOne + 1:].lstrip().rstrip()) #HOST:<address>:[<port>]
            else:
                break
            
    # GET <http/s>:<address>:<port>
    # GET <http/s>:<address>
    # GET <address>:<port>
    # GET <address>
    tempString = line_set[0]
    indexTwo = line_set[0].find(':')
    while indexTwo != -1:
        tempString = tempString[indexTwo + 1:].lstrip().rstrip()
        if tempString.isnumeric():
            return hostAddress, int(tempString) 
        indexTwo = tempString.find(':')     
    
    # http  = 80
    # https = 403
    if line_set[0].find('https://') != -1:
        return hostAddress, 403
    return hostAddress, 80

# messages from client (browser) -> proxy -> server
def handleRequests(clientSocket, addr):
    while True:
        request = clientSocket.recv(2048)
        if request:
            header = request.decode("utf-8","backslashreplace")
            
            file_name = None
            # parse the request to find address and port of host
            line_set = header.splitlines()
            hostAddress, hostPort = fetchHost(line_set)
            serverSocket = socket(AF_INET, SOCK_STREAM)

            if logging:
                parent_dir = os.path.join(os.getcwd(), 'Log')
                    
                # Path 
                path = os.path.join(parent_dir, hostAddress)
                if not os.path.isdir(path):
                    os.mkdir(path)
                
                this_uuid = str(uuid.uuid1())
                file_name = hostAddress + '.' + this_uuid + '.json'
                path = os.path.join(file_name, hostAddress)
                
                # Data to be written
                dictionary = {
                    "Incoming header" : header, 
                    # "Modified header" : newHeader,
                    # "Server response received" : "blank"
                }

                # Serializing json 
                json_object = json.dumps(dictionary, indent=3)
                
                # write to json file
                with open(file_name, "w") as outfile:
                    outfile.write(json_object)
            
            if line_set[0].lower().find('connect') != -1:
                print(addr, '>>> ', line_set[0])

                response = "HTTP/1.0 502 BAD GATEWAY \r\n\r\n"
                if serverSocket.connect_ex((hostAddress, hostPort)) == 0:
                    serverThread = threading.Thread(target=startResponse, args=(serverSocket,clientSocket,file_name), daemon=True)
                    clientThread = threading.Thread(target=startConnect, args=(serverSocket,clientSocket,file_name), daemon=True)
                    serverThread.start()
                    response = "HTTP/1.0 200 OK \r\n\r\n"

                if logging and file_name:
                    logMessage("Proxy response sent",response,file_name)
                
                clientSocket.send(response.encode('utf-8'))
            else: 
                # edit the request
                newHeader = editHeader(request, file_name)
                
                print(addr, '>>> ', newHeader.splitlines()[0])

                # establish connection with the host
                serverSocket.connect((hostAddress, hostPort))
                serverThread = threading.Thread(target=startResponse, args=(serverSocket,clientSocket,file_name), daemon=True)
                serverThread.start()

                serverSocket.send(newHeader.encode('utf-8'))

def findClients(proxySocket):
    proxySocket.listen()
    while True:
        clientSocket, addr = proxySocket.accept()
        
        clientThread = Thread(target=handleRequests, args=(clientSocket, addr), daemon=True)
        clientThread.start()

logging = False
if __name__ == '__main__':   
    serverPort = int(sys.argv[1])
    if len(sys.argv) > 2 and sys.argv[2].lower() == 'log':
        logging = True

        dir_path = os.path.join(os.getcwd(),'Log')
        if not os.path.isdir(dir_path):
            os.mkdir(dir_path)

    # proxy server:
    proxySocket = socket(AF_INET, SOCK_STREAM)
    proxySocket.bind((b'0.0.0.0', serverPort))

    proxyThread = threading.Thread(target=findClients, args=(proxySocket,), daemon=True)
    proxyThread.start()
    
    while True: # TODO: should only quit after EOF
        text = sys.stdin.readline()
        if (not text or (text == "q\n" and sys.stdin.isatty())):
            break
    proxySocket.close()